# Situation-Based Language Learning – REST API

This document describes the REST surface exposed by the Fastify backend located in `src/backend`. The API is intentionally small but opinionated: glosses and situations are the primary resources, challenges are managed as part of situations, and every response returns the shared DTOs from `src/shared`.

---

## Conventions

| Item | Details |
| --- | --- |
| Base URL | `http://localhost:3333` (configurable through `PORT`) |
| Protocols | HTTPS in production, HTTP locally |
| Content type | JSON (`application/json`) for both requests and responses |
| Auth | _None yet_ – add gateway/JWT once required |
| Error shape | `{ "error": string }` for handled errors, or `{ "error": "Validation error", "details": [...] }` for Zod validation failures |
| Timestamps | ISO 8601 strings (`createdAt`, `updatedAt`) |
| IDs | `cuid()` strings generated by Prisma |

All endpoints are versionless for now; introduce `/v1` when the contract stabilizes.

---

## Shared DTOs

Every payload reuses the shared TypeScript DTOs:

```ts
type GlossReference = {
  id: string;
  language: LanguageCode;
  content: string;
};

interface GlossDTO {
  id: string;
  content: string;
  isParaphrased: boolean;
  transcriptions: string[];
  notes: Note[];
  contains: GlossReference[];
  nearSynonyms: GlossReference[];
  nearHomophones: GlossReference[];
  translations: GlossReference[];
  clarifiesUsage: GlossReference[];
  toBeDifferentiatedFrom: GlossReference[];
}

interface SituationDTO {
  id: string;
  descriptions: LocalizedString[];
  imageLink?: string;
  targetLanguage: LanguageCode;
  nativeLanguage: LanguageCode;
  challengesOfExpression: GlossDTO[];
  challengesOfUnderstandingText: GlossDTO[];
}

interface SituationSummaryDTO {
  id: string;
  descriptions: LocalizedString[];
  imageLink?: string;
  targetLanguage: LanguageCode;
  nativeLanguage: LanguageCode;
  challengeCount: {
    expression: number;
    understanding: number;
  };
}
```

Resolution rules:

- Relation arrays now return lightweight `GlossReference` entries (`{ id, language, content }`) to avoid recursive loops.

---

## Health

| Method | Path | Description |
| --- | --- | --- |
| `GET` | `/health` | Returns `{ "status": "ok" }` when the server is ready. |

---

## Glosses

### List

```
GET /glosses?language=spa&content=hola
```

Query parameters (all optional):

| Param | Type | Description |
| --- | --- | --- |
| `language` | `LanguageCode` | Filter by language. Required if `content` is provided. |
| `content` | `string` | Filter by exact content. |

Response:

```json
{
  "data": [GlossDTO, ...]
}
```

### Search (fuzzy)

```
GET /glosses/search?language=spa&query=hol&limit=5
```

Helps find existing glosses while the CMS user is typing. Returns a short list of partial matches in the specified language, ordered by recent updates.

### Retrieve

```
GET /glosses/:id
```

Response is the fully resolved `GlossDTO`.

### Create

```
POST /glosses
```

Body schema (`glossWriteSchema`):

```json
{
  "language": "spa",
  "content": "¿Cómo estás?",
  "isParaphrased": false,
  "transcriptions": ["ˈkomo esˈtas"],
  "notes": [
    { "noteType": "usage", "content": "Informal greeting", "showBeforeSolution": true }
  ],
  "containsIds": ["clfj5q3d900001s8l2i9s8kdw"],
  "nearSynonymIds": [],
  "nearHomophoneIds": [],
  "translationIds": [],
  "clarifiesUsageIds": [],
  "toBeDifferentiatedFromIds": []
}
```

All relation arrays accept gloss IDs and default to `[]`. Missing IDs are ignored; unknown IDs trigger `404`.

### Update

```
PATCH /glosses/:id
```

Partial payload (`glossUpdateSchema`). Omitting a relation array leaves it unchanged; providing it replaces the entire set.

### Delete

```
DELETE /glosses/:id
```

No response body (`204`). Use the companion endpoint below to surface warnings:

```
GET /glosses/:id/references
```

Returns `{ "totalReferences": number, "breakdown": { ... } }`, counting every challenge/gloss that still points at the target gloss.

### Validation Errors

Zod returns:

```json
{
  "error": "Validation error",
  "details": [
    { "path": ["language"], "message": "Invalid enum value" }
  ]
}
```

---

## Situations

### List

```
GET /situations?targetLanguage=spa
```

Query parameters:

| Param | Required | Description |
| --- | --- | --- |
| `id` | Optional | Filter by situation id. |
| `targetLanguage` | Optional | Filter by target language code (e.g., "spa", "deu"). |
| `nativeLanguage` | Optional | Filter by native language code (e.g., "eng"). |

Response: `{ "data": [SituationDTO, ...] }`.

### List Summary

```
GET /situations/summary?targetLanguage=spa
```

Returns lightweight situation summaries without full challenge/gloss data. Ideal for list views.

Query parameters:

| Param | Required | Description |
| --- | --- | --- |
| `id` | Optional | Filter by situation id. |
| `targetLanguage` | Optional | Filter by target language code (e.g., "spa", "deu"). |
| `nativeLanguage` | Optional | Filter by native language code. |

Response: `{ "data": [SituationSummaryDTO, ...] }`.

### Retrieve

```
GET /situations/:id
```

Where `:id` is the situation id (cuid or seed value).

No additional query parameters are required for language filtering; the situation's
stored `nativeLanguage` determines how glosses are pruned.

Response is `{ "data": SituationDTO }`.

### Create

```
POST /situations
```

Body schema (`situationWriteSchema`):

```json
{
  "descriptions": [
    { "language": "eng", "content": "Basic greetings" },
    { "language": "deu", "content": "Erste Grüße" }
  ],
  "imageLink": "https://example.com/images/greeting.jpg",
  "targetLanguage": "spa",
  "nativeLanguage": "eng",
  "challengesOfExpressionIds": ["clm1a2b3c4d5e6f7g8h9i0j1k"],
  "challengesOfUnderstandingTextIds": ["cln2b3c4d5e6f7g8h9i0j1k2l"]
}
```

Notes:

- `targetLanguage` is required and specifies the language being learned (e.g., "spa" for Spanish situations).
- `nativeLanguage` is required and specifies the learner's base language for the situation (used for filtering glosses).
- `imageLink` is optional and must be a valid URL if provided.
- `descriptions` should include UI-friendly text in multiple languages to describe the situation.
- `challengesOfExpressionIds`: Array of gloss IDs in the native language (prompts for expression practice). Defaults to `[]`.
- `challengesOfUnderstandingTextIds`: Array of gloss IDs in the target language (text for comprehension practice). Defaults to `[]`.
- Glosses must be created separately via `/glosses` before attaching to situations.
- Glosses are unique per `(language, content)`. When a matching entry already exists, attach its `id` instead of creating a duplicate (`/glosses/search` helps surface candidates).

### Update

```
PATCH /situations/:id
```

Where `:id` is the situation id (cuid or seed-defined).

- Request body uses `situationUpdateSchema` (partial updates).
- Providing `challengesOfExpressionIds` or `challengesOfUnderstandingTextIds` replaces the entire gloss ID array for that challenge type.

### Delete

```
DELETE /situations/:id
```

Where `:id` is the situation id.

Removes the situation and its gloss associations. Glosses themselves are not deleted (they remain in the catalog for reuse).

---

## Status Codes

| Code | When |
| --- | --- |
| `200` | Successful GET/PATCH. |
| `201` | Resource created (POST). |
| `204` | Successful delete, no body. |
| `400` | Validation failure (Zod). |
| `404` | Resource not found (invalid ID or missing relation). |
| `409` | Unique constraint violation (duplicate gloss content per language). |
| `500` | Unhandled server error. |

---

## Local Development Checklist

1. `npm install`
2. Copy `src/backend/.env.example` → `.env`
3. `docker compose -f src/backend/docker-compose.yml up -d`
4. `npm run prisma:migrate:dev && npm run prisma:seed`
5. `npm run backend:dev`

The frontend CMS/CRAM apps consume the DTO shapes defined here and can depend on the documented endpoints to populate their UIs.
