# Situation-Based Language Learning – REST API

This document describes the REST surface exposed by the Fastify backend located in `src/backend`. The API is intentionally small but opinionated: glosses and situations are the primary resources, challenges are managed as part of situations, and every response returns the shared DTOs from `src/shared`.

---

## Conventions

| Item | Details |
| --- | --- |
| Base URL | `http://localhost:3333` (configurable through `PORT`) |
| Protocols | HTTPS in production, HTTP locally |
| Content type | JSON (`application/json`) for both requests and responses |
| Auth | _None yet_ – add gateway/JWT once required |
| Error shape | `{ "error": string }` for handled errors, or `{ "error": "Validation error", "details": [...] }` for Zod validation failures |
| Timestamps | ISO 8601 strings (`createdAt`, `updatedAt`) |
| IDs | `cuid()` strings generated by Prisma |

All endpoints are versionless for now; introduce `/v1` when the contract stabilizes.

---

## Shared DTOs

Every payload reuses the shared TypeScript DTOs:

```ts
interface GlossDTO {
  id: string;
  content: string;
  isParaphrased: boolean;
  transcriptions: string[];
  notes: Note[];
  contains: GlossDTO[];           // recursive
  nearSynonyms: GlossDTO[];       // depth 1
  nearHomophones: GlossDTO[];     // depth 1
  translations: GlossDTO[];       // depth 1
}

interface SituationDTO {
  identifier: string;
  descriptions: LocalizedString[];
  challengesOfExpression: ChallengeOfExpression[];
  challengesOfUnderstandingText: ChallengeOfUnderstandingText[];
}
```

Resolution rules:

- `contains` is resolved recursively to arbitrary depth.
- `nearSynonyms`, `nearHomophones`, `translations` are resolved exactly one level deep (their own relation arrays will be empty).

---

## Health

| Method | Path | Description |
| --- | --- | --- |
| `GET` | `/health` | Returns `{ "status": "ok" }` when the server is ready. |

---

## Glosses

### List

```
GET /glosses?language=spa&content=hola
```

Query parameters (all optional):

| Param | Type | Description |
| --- | --- | --- |
| `language` | `LanguageCode` | Filter by language. Required if `content` is provided. |
| `content` | `string` | Filter by exact content. |

Response:

```json
{
  "data": [GlossDTO, ...]
}
```

### Retrieve

```
GET /glosses/:id
```

Response is the fully resolved `GlossDTO`.

### Create

```
POST /glosses
```

Body schema (`glossWriteSchema`):

```json
{
  "language": "spa",
  "content": "¿Cómo estás?",
  "isParaphrased": false,
  "transcriptions": ["ˈkomo esˈtas"],
  "notes": [
    { "noteType": "usage", "content": "Informal greeting", "showBeforeSolution": true }
  ],
  "containsIds": ["clfj5q3d900001s8l2i9s8kdw"],
  "nearSynonymIds": [],
  "nearHomophoneIds": [],
  "translationIds": []
}
```

All relation arrays accept gloss IDs and default to `[]`. Missing IDs are ignored; unknown IDs trigger `404`.

### Update

```
PATCH /glosses/:id
```

Partial payload (`glossUpdateSchema`). Omitting a relation array leaves it unchanged; providing it replaces the entire set.

### Delete

```
DELETE /glosses/:id
```

No response body (`204`).

### Validation Errors

Zod returns:

```json
{
  "error": "Validation error",
  "details": [
    { "path": ["language"], "message": "Invalid enum value" }
  ]
}
```

---

## Situations

### List

```
GET /situations?identifier=greeting-basic
```

Query parameters:

| Param | Required | Description |
| --- | --- | --- |
| `identifier` | Optional | Filter by identifier. |

Response: `{ "data": [SituationDTO, ...] }`.

### Retrieve

```
GET /situations/:id
```

Where `:id` is the situation identifier (e.g., `greeting-basic`), not a cuid.

Response is `{ "data": SituationDTO }`.

### Create

```
POST /situations
```

Body schema (`situationWriteSchema`):

```json
{
  "identifier": "greeting-basic",
  "descriptions": [
    { "language": "spa", "content": "Primeros saludos" },
    { "language": "deu", "content": "Erste Grüße" }
  ],
  "challengesOfExpression": [
    {
      "prompt": "Saluda a un amigo",
      "glossIds": ["clfj5q3d900001s8l2i9s8kdw"]
    }
  ],
  "challengesOfUnderstandingText": [
    {
      "text": "Hola, ¿cómo estás?",
      "language": "spa",
      "glossIds": ["clfj5q3d900001s8l2i9s8kdw"]
    }
  ]
}
```

Notes:

- `language` in the payload is used only to shape the response.
- Challenge arrays default to `[]`; omit them to create empty situations.

### Update

```
PATCH /situations/:id?language=spa
```

Where `:id` is the situation identifier (e.g., `greeting-basic`).

- Request body uses `situationUpdateSchema`.
- Providing `challengesOfExpression` or `challengesOfUnderstandingText` replaces all existing challenges of that type (internally a delete + recreate).
- The `language` query parameter controls the response DTO.

### Delete

```
DELETE /situations/:id
```

Where `:id` is the situation identifier (e.g., `greeting-basic`).

Also deletes associated challenges (cascade).

---

## Status Codes

| Code | When |
| --- | --- |
| `200` | Successful GET/PATCH. |
| `201` | Resource created (POST). |
| `204` | Successful delete, no body. |
| `400` | Validation failure (Zod). |
| `404` | Resource not found (invalid ID or missing relation). |
| `409` | Unique constraint violation (duplicate gloss content per language, duplicate situation identifier). |
| `500` | Unhandled server error. |

---

## Local Development Checklist

1. `npm install`
2. Copy `src/backend/.env.example` → `.env`
3. `docker compose -f src/backend/docker-compose.yml up -d`
4. `npm run prisma:migrate:dev && npm run prisma:seed`
5. `npm run backend:dev`

The frontend CMS/CRAM apps consume the DTO shapes defined here and can depend on the documented endpoints to populate their UIs.
